<html>

<head>
    <title>MIDI chord sequencer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
        max-width: 34em;
        margin: 1em auto;
    }

    h1,
    p,
    button,
    select,
    li {
        font-family: courier;
        max-width: 34em;
    }

    textarea {
        width: 100%;
        overflow-x: scroll;
        resize: none;
        white-space: nowrap;
    }
    </style>
</head>

<body>
    <div id="app">
        <h1>MIDI Chord Sequencer</h1>
        <ul>
            <li>There are 24 pulses per quarternote</li>
            <li>Each measure has an adjustable number of quarter notes (2 - 4)</li>
            <li>Each line is one measure</li>
            <li>Each note cluster (notes with no spaces between) is subdivided into a measure equally, based on the number of note clusters (e.g. <code>CEG CEG</code> at <sup>4</sup>‚ÅÑ<sub>4</sub> will be played for two beats each, and <code>CEG CEG CEG CEG</code> will be played for one beat each)</li>
            <li>A non-note character indicates a rest (e.g. <code>CEG . CEG .</code> plays Cmaj on the 1st and 3rd beat)</li>
            <li>A note cluster is non-separated list of notes and their octaves. If there is no octave information, the note chosen will be closest to the preceding note. (e.g. <code>C3B</code> will play <code>C3</code> and <code>B2</code>, while <code>C3B3</code> will play <code>C3</code> and <code>B3</code>).</li>
            <li>A song is a group of measures (a set of lines). Each song will be transmitted to a MIDI channel.</li>
            <li>Instruments are loaded in a separate area and can be assigned to any MIDI channel</li>
            <li>Songs are saved</li>
        </ul>
        <p>{{message}}</p>
        <div v-for='(device,devi) in devices'>
            <p>{{device}}
                <select v-model='devices[devi].part'>
                    <option v-for='(part,index) in parts' v-bind:value='index'>part {{index}}
                    </option>
                </select>
            </p>
        </div>
        <br>
        qn / measure: <input v-model='options.qn_per_measure' type='number' size=2>
        <br>
        tempo: <input v-model='options.tempo' type='number' size=2>
        <br>
        <button v-on:click="startSong">
            Start
        </button>
        <button v-on:click="stopSong">
            Stop
        </button>
        <button v-on:click="parts.push({text:``,legato:100});">
            Add part
        </button>
        <p v-for='(part,parti) in parts'>
            part {{parti}}, legato: <input v-model='parts[parti].legato' type='number' size=2 min=0 max=100>
            <textarea rows=6 v-model='parts[parti].text'></textarea>
        </p>
    </div>
    </div>
    <script src="./static/js/chord-magic.min.js"></script>
    <script src="./static/js/vue.js"></script>
    <script src="./static/js/tonal.min.js"></script>
    <script src="./static/js/webmidi.js"></script>
    <script>
    const PULSES_PER_QUARTER_NOTE = 24;

    var app = new Vue({
        el: '#app',
        data: {
            message: '',
            devices: [{ name: 'op-1', part: 0 }, { name: 'sh01a', part: 0 }],
            parts: [{ text: 'CEG\nFAC FAC\nAEC AEC AEC AEC', legato: 100 }],
            options: { tempo: 90, qn_per_measure: 4 },
            metronome_expected: 0,
            metronome: null,
            metronome_expected: Date.now(),
            metronome_flag_stop: false,
            metronome_pulse: 0,
            metronome_beat: 0,
            metronome_measure: 0,
        },
        mounted: function() {
            console.log("loaded");
            var _this = this;
            WebMidi.enable(function(err) {
                if (err) {
                    _this.message = "WebMidi could not be enabled, make sure you are using Chrome"
                } else {
                    names = []
                    for (var i = 0; i < WebMidi.outputs.length; i++) {
                        _this.devices.push({ name: WebMidi.outputs[i].name, part: 0 })
                    }
                    if (_this.devices.length == 0) {
                        _this.message = "No devices attached."
                    }
                }
            });
        },
        methods: {
            startSong: function(e) {
                console.log("starting song");
                this.startMetronome();
            },
            stopSong: function(e) {
                console.log("stopping song");
                this.stopMetronome();
            },
            step: function(e) {
                if (this.metronome_flag_stop) {
                    return;
                }
                var dt = Date.now() - this.metronome_expected;
                if (dt > this.bpminterval) {
                    // something really bad happened. Maybe the browser (tab) was inactive?
                    // possibly special handling to avoid futile "catch up" run
                }
                this.metronome_expected += this.bpminterval;
                this.metronome = setTimeout(this.step, Math.max(0, this.bpminterval - dt));

                // advance the beat and measure
                this.metronome_pulse++;
                if (this.metronome_pulse == PULSES_PER_QUARTER_NOTE) {
                    this.metronome_pulse = 0;
                }
                if (this.metronome_pulse == 0) {
                    this.metronome_beat++;
                    if (this.metronome_beat == this.options.qn_per_measure) {
                        this.metronome_beat = 0;
                    }
                    if (this.metronome_beat == 0) {
                        this.metronome_measure++;
                        this.metronome_beat = 0;
                    }
                    console.log(`measure ${this.metronome_measure}, beat ${this.metronome_beat}`);
                }

                // start/stop playing notes
                const pulse = this.metronome_pulse + PULSES_PER_QUARTER_NOTE * this.metronome_beat;
                const measure = this.metronome_measure;
                for (var [i, p] of this.midinotes.entries()) {
                    const m = measure % p.length;
                    if (pulse in p[m]) {
                        // turn on/off notes
                        console.log(i, p[m][pulse]);
                    }
                }
            },
            startMetronome: function() {
                this.metronome_beat = -1;
                this.metronome_measure = -1;
                this.metronome_pulse = -1;
                this.metronome_flag_stop = false;
                this.metronome_expected = Date.now();
                this.step();
            },
            stopMetronome: function() {
                this.metronome_flag_stop = true;
            },
        },
        computed: {
            bpminterval: function() {
                return 60 / this.options.tempo / PULSES_PER_QUARTER_NOTE * 1000;
            },
            midinotes: function() {
                part_measures = [];
                for (var [i, p] of this.parts.entries()) {
                    // iterate over measures
                    measures = [];
                    for (var [j, line] of p.text.split("\n").entries()) {
                        line = line.trim();
                        if (line.length == 0) {
                            continue;
                        }
                        // iterate over clusters
                        cn = {}
                        const clusters = line.split(" ");
                        const pulses_per_cluster = this.options.qn_per_measure * PULSES_PER_QUARTER_NOTE / clusters.length;
                        for (var [k, cluster] of clusters.entries()) {
                            // TODO: figure out the notes in each cluster
                            cn[pulses_per_cluster * k] = { 'notes': cluster, 'on': true }
                            var offset_time = (parseFloat(p.legato) / 100.0 * pulses_per_cluster);
                            if (offset_time < 1) {
                                offset_time = 1;
                            } else if (offset_time >= pulses_per_cluster) {
                                offset_time = pulses_per_cluster - 1;
                            }
                            cn[pulses_per_cluster * k] = { 'notes': cluster, 'press': 'on' }
                            cn[pulses_per_cluster * k + offset_time] = { 'notes': cluster, 'press': 'off' }
                        }
                        measures.push(cn);
                    }
                    part_measures.push(measures);
                }
                return part_measures;
            },
        }
    });
    </script>
</body>

</html>