<html>

<head>
    <title>MIDI chord sequencer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
        max-width: 34em;
        margin: 1em auto;
    }

    h1,
    p,
    button,
    select,
    li {
        font-family: courier;
        max-width: 34em;
    }

    textarea {
        width: 100%;
        overflow-x: scroll;
        resize: none;
        white-space: nowrap;
    }
    </style>
</head>

<body>
    <div id="app">
        <h1>MIDI Chord Sequencer</h1>
        <p>{{message}}</p>
        <button v-on:click="startSong">
            Start
        </button>
        <button v-on:click="stopSong">
            Stop
        </button>
        <h1>Parts</h1>
        <button v-on:click="parts.push({text:``,legato:100});">
            Add part
        </button>
        <p v-for='(part,parti) in parts'>
            part {{parti}}, legato: <input v-model='parts[parti].legato' type='number' size=4 min=0 max=100>
            <textarea rows=6 v-model='parts[parti].text' style="white-space: pre;"></textarea>
        </p>
        <h1>Devices</h1>
        <div v-for='(device,devi) in devices'>
            <p>{{device.name}}
                <!--<span v-if="device.current">playing {{device.current}}</span>-->
                <p v-for='(section,si) in sections'>
                    section {{si}}
                    <select v-model='device.parts[si]'>
                        <option v-bind:value='-1'>silent</option>
                        <option v-for='(part,index) in parts' v-bind:value='index'>part {{index}}
                        </option>
                    </select>
                </p>
            </p>
        </div>
        <h1>Options</h1>
        qn / measure: <input v-model='options.qn_per_measure' type='number' size=2>
        <br>
        tempo: <input v-model='options.tempo' type='number' size=2>
        <h1>Sections</h1>
        <button v-on:click="sections.push({measures:4});">
            Add section
        </button>
        <p v-for='(section,i) in sections'>
            section {{i}} measures: <input v-model='section.measures' type='number' size=2>
        </p>
    </div>
    </div>
    <script src="./static/js/chord-magic.min.js"></script>
    <script src="./static/js/vue.js"></script>
    <script src="./static/js/tonal.min.js"></script>
    <script src="./static/js/webmidi.js"></script>
    <script>
    const PULSES_PER_QUARTER_NOTE = 24;

    // TODO 
    function chordClusterToMIDIs(chord_cluster) {
        chord_cluster += 'z';
        // Tonal.Note.midi('Bb4C')
        var lastNote = 'C4';
        var lastOctave = parseInt(lastNote.charAt(lastNote.length - 1));
        // get the biggest Tonal Note I can
        // if there is no number at the end, find the closest note
        // to last note
        // use look for undefined
        var i = 0;
        var notes = [];
        while (i < chord_cluster.length - 1) {
            var note = '';
            for (var j = i + 1; j <= chord_cluster.length; j++) {
                var note_temp = chord_cluster.substring(i, j);
                var midi_note = Tonal.Note.midi(note_temp);

                if (midi_note == null && isNaN(parseInt(note_temp.charAt(note_temp.length - 1))) == true) {
                    // need to add octave
                    var best_distance = 100;
                    var best_octave = lastOctave;
                    for (var octave = lastOctave - 1; octave <= lastOctave + 1; octave++) {
                        var distance = Math.abs(Tonal.Interval.semitones(Tonal.Interval.distance(lastNote, note_temp + octave)));
                        if (distance < best_distance) {
                            best_distance = distance;
                            best_octave = octave;
                        }
                    }
                    note_temp = note_temp + best_octave;
                    midi_note = Tonal.Note.midi(note_temp);
                }
                if (midi_note == undefined) {
                    if (j == i + 1) {
                        return notes;
                    }
                    i = j - 1;
                    break
                }
                note = note_temp;
            }
            notes.push({ 'note': note, 'midi': Tonal.Note.midi(note) });
            lastNote = note;
            lastOctave = parseInt(lastNote.charAt(lastNote.length - 1));
        }
        return notes;
    }

    console.log(JSON.stringify(chordClusterToMIDIs('A .')));
    var app = new Vue({
        el: '#app',
        data: {
            message: '',
            devices: [{ name: 'op-1', parts: [-1, -1, -1, -1, -1], current: '' }, { name: 'sh01a', parts: [-1, -1, -1, -1, -1], current: '' }],
            // TODO: add sections (encapsulate parts)
            sections: [{ measures: 4 }],
            parts: [{ text: 'CEG\nFAC FAC\nAEC AEC AEC AEC', legato: 100 }],
            options: { tempo: 90, qn_per_measure: 4 },
            is_playing: false,
            metronome_expected: 0,
            metronome: null,
            metronome_expected: Date.now(),
            metronome_flag_stop: false,
            metronome_pulse: 0,
            metronome_beat: 0,
            metronome_measure: 0,
            metronome_section: 0,
        },
        mounted: function() {
            console.log("loaded");
            var _this = this;
            WebMidi.enable(function(err) {
                if (err) {
                    _this.message = "WebMidi could not be enabled, make sure you are using Chrome"
                } else {
                    names = []
                    for (var i = 0; i < WebMidi.outputs.length; i++) {
                        _this.devices.push({ name: WebMidi.outputs[i].name, parts: [-1, -1, -1, -1, -1, -1, -1] })
                    }
                    if (_this.devices.length == 0) {
                        _this.message = "No devices attached."
                    }
                }
            });
        },
        methods: {
            startSong: function(e) {
                console.log("starting song");
                this.startMetronome();
            },
            stopSong: function(e) {
                console.log("stopping song");
                this.stopMetronome();
            },
            step: function(e) {
                if (this.metronome_flag_stop) {
                    return;
                }
                var dt = Date.now() - this.metronome_expected;
                console.log(dt);
                if (dt > this.bpminterval) {
                    console.log('UH OH UH OH')
                    // something really bad happened. Maybe the browser (tab) was inactive?
                    // possibly special handling to avoid futile "catch up" run
                }
                this.metronome_expected += this.bpminterval;
                this.metronome = setTimeout(this.step, Math.max(0, this.bpminterval - dt));

                // advance the beat and measure
                this.metronome_pulse++;
                if (this.metronome_pulse == PULSES_PER_QUARTER_NOTE) {
                    this.metronome_pulse = 0;
                }
                if (this.metronome_pulse == 0) {
                    this.metronome_beat++;
                    if (this.metronome_beat == this.options.qn_per_measure) {
                        this.metronome_beat = 0;
                    }
                    if (this.metronome_beat == 0) {
                        this.metronome_measure++;
                        this.metronome_beat = 0;
                    }
                    console.log(`measure ${this.metronome_measure}, beat ${this.metronome_beat}`);
                }

                // for each device, emit notes from part in the current section
                const pulse = this.metronome_pulse + PULSES_PER_QUARTER_NOTE * this.metronome_beat;
                const measure = this.metronome_measure;
                const section = this.metronome_section;
                for (var [devicei, device] of this.devices.entries()) {
                    const parti = device.parts[section];
                    if (parti == -1) {
                        // skip this device
                        continue
                    }
                    const p = this.midinotes[parti];
                    const m = measure % p.length;
                    if (pulse in p[m]) {
                        // turn on/off notes
                        // empty notes = rest
                        if (p[m][pulse].notes.length == 0) {
                            console.log('rest');
                            this.devices[devicei].current = ''
                        } else {
                            console.log(devicei, parti, JSON.stringify(p[m][pulse]));
                            if (p[m][pulse].press == 'on') {
                                this.devices[devicei].current = `measure ${m}, pulse ${pulse}: ${p[m][pulse].cluster}`;
                            } else {
                                this.devices[devicei].current = '';
                            }
                        }
                    }
                }
            },
            startMetronome: function() {
                this.is_playing = true;
                this.metronome_beat = -1;
                this.metronome_measure = -1;
                this.metronome_pulse = -1;
                this.metronome_flag_stop = false;
                this.metronome_expected = Date.now();
                this.step();
            },
            stopMetronome: function() {
                this.is_playing = false;
                this.metronome_flag_stop = true;
            },
        },
        computed: {
            bpminterval: function() {
                return 60 / this.options.tempo / PULSES_PER_QUARTER_NOTE * 1000;
            },
            midinotes: function() {
                part_measures = [];
                for (var [i, p] of this.parts.entries()) {
                    // iterate over measures
                    measures = [];
                    for (var [j, line] of p.text.split("\n").entries()) {
                        line = line.trim();
                        if (line.length == 0) {
                            continue;
                        }
                        // iterate over clusters
                        cn = {}
                        const clusters = line.split(" ");
                        const pulses_per_cluster = this.options.qn_per_measure * PULSES_PER_QUARTER_NOTE / clusters.length;
                        for (var [k, cluster] of clusters.entries()) {
                            // TODO: figure out the notes in each cluster
                            cn[pulses_per_cluster * k] = { 'notes': cluster, 'on': true }
                            var offset_time = (parseFloat(p.legato) / 100.0 * pulses_per_cluster);
                            if (offset_time < 1) {
                                offset_time = 1;
                            } else if (offset_time >= pulses_per_cluster) {
                                offset_time = pulses_per_cluster - 1;
                            }
                            midi_cluster = chordClusterToMIDIs(cluster);
                            cn[pulses_per_cluster * k] = { 'cluster': cluster, 'notes': midi_cluster, 'press': 'on' }
                            if (midi_cluster.length > 0) {
                                cn[pulses_per_cluster * k + offset_time] = { 'cluster': cluster, 'notes': midi_cluster, 'press': 'off' }
                            }
                        }
                        measures.push(cn);
                    }
                    part_measures.push(measures);
                }
                return part_measures;
            },
        }
    });
    </script>
</body>

</html>